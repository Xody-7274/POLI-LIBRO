<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5.2 Principios del Software de E/S</title>
    <link rel="icon" type="image/png" href="logoescom.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /*
        Aquí comienza un bloque de estilos CSS para definir la apariencia de la página.
        Incluye:
        - Variables de color (--primary, --secondary, etc.) para un diseño consistente.
        - Estilos base para todos los elementos (*).
        - Estilos para el cuerpo de la página (body), incluyendo un fondo degradado.
        - Diseño de componentes específicos como botones flotantes, menú lateral, contenedor principal,
          encabezados, secciones, tablas, bloques de código, tarjetas de actividad, pie de página, etc.
        - Media Queries (@media) para adaptar el diseño a pantallas más pequeñas (diseño responsivo).
        */
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --gray: #95a5a6;
            --success: #2ecc71;
            --warning: #f39c12;
            --card-bg: rgba(255, 255, 255, 0.05);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a3a, #2c3e50);
            color: var(--light);
            min-height: 100vh;
            line-height: 1.7;
        }

        /* Botón flotante de inicio */
        .floating-home-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 1.5rem;
        }

        .floating-home-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.4);
        }

        /* Menú de navegación lateral */
        .sidebar-nav {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
            transition: transform 0.3s ease;
            transform: translateX(-100%);
            overflow-y: auto;
        }

        .sidebar-nav.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(52, 152, 219, 0.1);
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        }

        .sidebar-title {
            font-size: 1.2rem;
            color: var(--secondary);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .sidebar-subtitle {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .nav-sections {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 15px;
        }

        .nav-section-title {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
            margin-bottom: 10px;
        }

        .nav-item {
            display: block;
            padding: 12px 20px;
            color: var(--light);
            text-decoration: none;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-left-color: var(--secondary);
            padding-left: 25px;
        }

        .nav-item.active {
            background: rgba(52, 152, 219, 0.2);
            border-left-color: var(--secondary);
            color: var(--secondary);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        /* Botón toggle del menú */
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--primary);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1001;
            font-size: 1.2rem;
        }

        .menu-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        .menu-toggle.active {
            background: var(--accent);
        }

        /* Indicador de progreso de lectura */
        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 998;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--success));
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Overlay para cerrar el menú */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* Contenedor principal con espaciado para botones flotantes */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            transition: margin-left 0.3s ease, margin-right 0.3s ease;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .breadcrumb {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            color: var(--gray);
            font-size: 1.1rem;
        }
        
        .breadcrumb a {
            color: var(--secondary);
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .breadcrumb a:hover {
            color: white;
            text-decoration: underline;
        }
        
        .breadcrumb span {
            margin: 0 10px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: white;
        }
        
        .subtitle {
            font-size: 1.8rem;
            color: var(--secondary);
            margin-bottom: 20px;
            font-weight: 300;
            text-align: center;
        }
        
        .intro {
            max-width: 900px;
            margin: 0 auto 40px;
            padding: 25px;
            background: var(--card-bg);
            border-radius: 15px;
            border-left: 4px solid var(--secondary);
            text-align: justify;
        }
        
        .section {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            scroll-margin-top: 100px;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--secondary);
        }
        
        .section-number {
            font-size: 2.2rem;
            font-weight: bold;
            color: var(--secondary);
            margin-right: 15px;
            min-width: 120px;
        }
        
        .section-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: white;
        }
        
        .content {
            padding: 0 10px;
        }
        
        .content h3 {
            font-size: 1.5rem;
            color: var(--secondary);
            margin: 30px 0 15px;
            padding-left: 10px;
            border-left: 3px solid var(--accent);
        }
        
        .content h4 {
            font-size: 1.3rem;
            color: var(--warning);
            margin: 25px 0 12px;
            padding-left: 8px;
        }
        
        .content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .content ul, .content ol {
            padding-left: 30px;
            margin: 20px 0;
        }
        
        .content li {
            margin-bottom: 12px;
        }
        
        .highlight {
            background: rgba(231, 76, 60, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .citation {
            font-style: italic;
            color: var(--gray);
            margin: 5px 0 15px 20px;
            border-left: 2px solid var(--secondary);
            padding-left: 10px;
        }
        
        .table-container {
            max-width: 800px;
            margin: 30px auto;
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.2);
        }
        
        th {
            background: var(--primary);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .table-caption {
            text-align: center;
            padding: 10px;
            font-style: italic;
            color: var(--gray);
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        
        .code-block {
            background: #1e1e1e;
            color: #dcdcdc;
            border-radius: 10px;
            padding: 20px;
            margin: 25px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            position: relative;
            border-left: 4px solid var(--warning);
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .code-caption {
            font-style: italic;
            margin-top: 10px;
            color: var(--gray);
            text-align: center;
        }
        
          .figure-container {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .figure-placeholder {
            width: 100%;
            height: 300px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            margin: 15px 0;
            color: var(--gray);
            font-style: italic;
            flex-direction: column;

        }
        
        .figure-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--secondary);
        }
        
        .figure-caption {
            font-style: italic;
            color: var(--gray);
            margin-top: 10px;
        }

        .imagen-figura2 {
            max-width: 200px;
            width: 100%;
            height: auto;
        }

        .imagen-figura3 {
            max-width: 200px;
            width: 100%;
            height: auto;
        }

        .imagen-figura4 {
            max-width: 200px;
            width: 100%;
            height: auto;
        }
        
        .activity-card {
            background: rgba(46, 204, 113, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 40px 0;
            border-left: 4px solid var(--success);
            text-align: center;
        }
        
        .activity-title {
            font-size: 1.8rem;
            color: var(--success);
            margin-bottom: 20px;
        }
        
        .activity-btn {
            display: inline-block;
            background: var(--success);
            color: white;
            padding: 15px 35px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }
        
        .activity-btn:hover {
            background: #27ae60;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        
        .nav-btn {
            display: inline-flex;
            align-items: center;
            background: var(--secondary);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
        }
        
        .nav-btn i {
            margin: 0 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 60px;
            padding: 30px;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Botón de ir arriba */
        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
            z-index: 999;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: #c0392b;
            transform: translateY(-3px);
        }
        
        @media (max-width: 768px) {
            .sidebar-nav {
                width: 100%;
            }

            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1.4rem;
            }
            
            .section-title {
                font-size: 1.5rem;
            }
            
            .section-number {
                min-width: 100px;
                font-size: 1.8rem;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
                text-align: center;
                justify-content: center;
            }

            .floating-home-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Indicador de progreso de lectura -->
    <div class="reading-progress">
        <div class="reading-progress-bar" id="progressBar"></div>
    </div>

    <!-- Botón toggle del menú -->
    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Botón flotante de inicio -->
    <a href="index.html" class="floating-home-btn" title="Ir al inicio">
        <i class="fas fa-home"></i>
    </a>

    <!-- Overlay para cerrar el menú -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Menú de navegación lateral -->
    <nav class="sidebar-nav" id="sidebarNav">
        <div class="sidebar-header">
            <div class="sidebar-title">5.2 Software de E/S</div>
            <div class="sidebar-subtitle">Gestión eficiente de entrada y salida</div>
        </div>
        
        <div class="nav-sections">
            <div class="nav-section">
                <div class="nav-section-title">Navegación</div>
                <a href="#inicio" class="nav-item">
                    <i class="fas fa-home"></i>
                    Inicio de la unidad
                </a>
                <a href="index.html" class="nav-item">
                    <i class="fas fa-arrow-left"></i>
                    Menú principal
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Contenido</div>
                <a href="#introduccion" class="nav-item" data-section="introduccion">
                    <i class="fas fa-info-circle"></i>
                    Introducción General
                </a>
                <a href="#seccion-5-2-1" class="nav-item" data-section="5-2-1">
                    <i class="fas fa-bullseye"></i>
                    5.2.1 Objetivos del Software de E/S
                </a>
                <a href="#seccion-5-2-2" class="nav-item" data-section="5-2-2">
                    <i class="fas fa-code"></i>
                    5.2.2 E/S Programadas
                </a>
                <a href="#seccion-5-2-3" class="nav-item" data-section="5-2-3">
                    <i class="fas fa-bolt"></i>
                    5.2.3 E/S Manejadas por Interrupciones
                </a>
                <a href="#seccion-5-2-4" class="nav-item" data-section="5-2-4">
                    <i class="fas fa-memory"></i>
                    5.2.4 E/S usando DMA
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Recursos</div>
                <a href="actividad_5_2.html" class="nav-item">
                    <i class="fas fa-tasks"></i>
                    Actividad de aprendizaje
                </a>
                <a href="5.1.html" class="nav-item">
                    <i class="fas fa-arrow-left"></i>
                    Anterior: Hardware de E/S
                </a>
                <a href="5.3.html" class="nav-item">
                    <i class="fas fa-arrow-right"></i>
                    Siguiente: Capas de Software
                </a>
            </div>
        </div>
    </nav>

    <!-- Botón de ir arriba -->
    <button class="scroll-to-top" id="scrollToTop">
        <i class="fas fa-chevron-up"></i>
    </button>

    <div class="container">
        <header id="inicio">
            <div class="breadcrumb">
                <a href="index.html"><i class="fas fa-home"></i> Inicio</a>
                <span>/</span>
                <a href="index.html">Unidad 5</a>
                <span>/</span>
                <span>5.2 Principios del Software de E/S</span>
            </div>
            <h1>5.2 Principios del Software de E/S</h1>
            <div class="subtitle">Gestión eficiente de entrada y salida a nivel de software</div>
        </header>
        
        <!-- Introducción General -->
        <div class="section" id="introduccion">
            <div class="section-header">
                <div class="section-number">Introducción</div>
            </div>
            <div class="content">
                <p>El software de E/S actúa como intermediario entre el hardware y los dispositivos periféricos. Su función principal es gestionar la interacción con los dispositivos mediante capas de abstracción, permitiendo a los programadores trabajar sin manipular detalles técnicos como registros, interrupciones o protocolos específicos.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>

                <h3>Principios del Software de E/S</h3>

                <p>El sistema operativo no se comunica directamente con el hardware, sino a través del software de E/S, que funciona como una capa de traducción entre los programas de usuario y los dispositivos físicos.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>

                <p>Para lograrlo, se utilizan controladores de dispositivos (drivers), que permiten al sistema operativo gestionar distintos tipos de hardware de manera uniforme, sin importar sus diferencias internas.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>

                <p>Las funciones principales del software de E/S incluyen la lectura y escritura de datos, así como tareas adicionales como configurar, encender, apagar y verificar el estado de un dispositivo.</p>
                <p class="citation">(Stallings, 2020)</p>
                
                <h3>Gestión del Tiempo en Operaciones de E/S</h3>
                <p>Existen dos modos principales para manejar el tiempo durante operaciones de entrada y salida:</p>
                
                <p><span class="highlight">Síncrono:</span> El programa espera a que termine la operación antes de continuar. Es más simple de programar, pero puede causar demoras si el dispositivo es lento.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <p><span class="highlight">Asíncrono:</span> El programa inicia la operación y continúa ejecutándose. Al finalizar la E/S, el sistema le notifica. Este método mejora el rendimiento general, aunque su implementación es más compleja.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <p>El objetivo del software de E/S es lograr una interacción organizada y eficiente, ya sea con un disco duro o una tarjeta de red.</p>
                
                <h3>Clasificación de Dispositivos de E/S</h3>
                <p>Los dispositivos de entrada/salida pueden clasificarse según diferentes criterios. La Tabla 6 resume esta clasificación, incluyendo ejemplos y características relacionadas con el software de E/S.</p>
                <p class="citation">(Stallings, 2020)</p>
                
                <div class="table-container">
                    <table>
                        <tr>
                            <th>Criterio</th>
                            <th>Tipos</th>
                            <th>Ejemplos</th>
                            <th>Características del Software de E/S</th>
                        </tr>
                        <tr>
                            <td rowspan="2">Unidad de transferencia</td>
                            <td>Dispositivos de caracteres</td>
                            <td>Teclados, ratones, impresoras</td>
                            <td>Transferencia byte a byte, sin buffer estructurado.</td>
                        </tr>
                        <tr>
                            <td>Dispositivos de bloques</td>
                            <td>Discos duros, unidades SSD, DVD</td>
                            <td>Transferencia en unidades de bloque, caché estructurado.</td>
                        </tr>
                        <tr>
                            <td rowspan="2">Patrón de acceso</td>
                            <td>Secuencial</td>
                            <td>Cintas magnéticas, puertos serie</td>
                            <td>Algoritmos optimizados para acceso consecutivo.</td>
                        </tr>
                        <tr>
                            <td>Aleatorio</td>
                            <td>Discos, memoria flash</td>
                            <td>Algoritmos de planificación de acceso.</td>
                        </tr>
                        <tr>
                            <td rowspan="2">Velocidad</td>
                            <td>Alta velocidad</td>
                            <td>GPUs, redes de alta velocidad</td>
                            <td>DMA, interrupciones vectorizadas, buffers múltiples.</td>
                        </tr>
                        <tr>
                            <td>Baja velocidad</td>
                            <td>Dispositivos HID, impresoras</td>
                            <td>Polling, interrupciones simples.</td>
                        </tr>
                    </table>
                    <div class="table-caption">Tabla 6. Clasificación de dispositivos de entrada/salida</div>
                </div>
                
                <h3>Interfaces de Programación de E/S (APIs)</h3>
                <p>Las APIs de E/S son puntos de acceso entre las aplicaciones y el sistema operativo. Permiten que un programa decida si desea leer o escribir en un dispositivo.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <p>Con el tiempo, estas interfaces han evolucionado. En sus inicios estaban estrechamente vinculadas al hardware, pero actualmente se apoyan en abstracciones que simplifican el desarrollo de software y aumentan la portabilidad.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <h3>Modelos de Comunicación entre Programas y Dispositivos</h3>
                <p>Los principales modelos de comunicación entre aplicaciones y dispositivos periféricos son:</p>
                
                <p><span class="highlight">1. Modelo de Bloqueo Síncrono:</span> El proceso se detiene hasta que finaliza la operación de E/S. Es sencillo de programar, pero desaprovecha recursos del sistema.</p>
                <p class="citation">(Stallings, 2020)</p>
                
                <p><span class="highlight">2. Modelo No Bloqueante Asíncrono:</span> El proceso lanza la operación y continúa ejecutándose. El sistema notifica al proceso cuando la E/S termina. Mejora el rendimiento, pero exige un manejo más cuidadoso de estados y condiciones de carrera.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <p><span class="highlight">3. Modelo Basado en Eventos:</span> Se registran handlers (funciones manejadoras) que se ejecutan automáticamente ante ciertos eventos (como la llegada de datos). Es ideal para aplicaciones con múltiples dispositivos o conexiones simultáneas, como los servidores.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <h3>Mecanismos de Notificación Asíncrona</h3>
                <p>El sistema operativo dispone de diversos mecanismos para notificar la finalización de operaciones de E/S asíncronas. En la Tabla 7 se presenta una comparativa entre estos mecanismos según su descripción, plataforma y ventajas.</p>
                <p class="citation">(Stallings, 2020)</p>
                
                <div class="table-container">
                    <table>
                        <tr>
                            <th>Mecanismo</th>
                            <th>Descripción</th>
                            <th>Plataforma</th>
                            <th>Ventajas</th>
                            <th>Desventajas</th>
                        </tr>
                        <tr>
                            <td>Select()/poll()</td>
                            <td>Se encarga de revisar y monitorear en varios dispositivos.</td>
                            <td>Multiplataforma</td>
                            <td>Simple, estándar</td>
                            <td>Escalamiento limitado, O(n)</td>
                        </tr>
                        <tr>
                            <td>epoll</td>
                            <td>API avanzado para monitorizar descriptores (muchos eventos)</td>
                            <td>Linux</td>
                            <td>Escalamiento O(1), eficiente</td>
                            <td>Solo de Linux</td>
                        </tr>
                        <tr>
                            <td>kqueue</td>
                            <td>Es similar a epoll</td>
                            <td>BSD, macOS</td>
                            <td>Flexible, eficiente</td>
                            <td>No disponible en Linux/Windows</td>
                        </tr>
                        <tr>
                            <td>IOCP</td>
                            <td>Manejo eficiente de entrada y salida</td>
                            <td>Windows</td>
                            <td>Alto rendimiento, rápido, escalable</td>
                            <td>Específico de Windows</td>
                        </tr>
                        <tr>
                            <td>AIO POSIX</td>
                            <td>E/S asíncrona estándar</td>
                            <td>UNIX</td>
                            <td>Estandarizado</td>
                            <td>Depende del sistema</td>
                        </tr>
                        <tr>
                            <td>io_uring</td>
                            <td>API moderno (nuevo) de E/S asíncrona, rápido y flexible</td>
                            <td>Linux moderno</td>
                            <td>Alto rendimiento, completa</td>
                            <td>Nueva, específica de Linux</td>
                        </tr>
                    </table>
                    <div class="table-caption">Tabla 7. Mecanismos de notificación asíncrona en operaciones de E/S</div>
                </div>
                
                <h3>Ejemplo de Lectura y Escritura con E/S Bloqueante y No Bloqueante</h3>
                <p>A continuación, se muestra el Código 4 en C que permite al usuario elegir entre dos modos de E/S: bloqueante y no bloqueante. Este ejemplo ilustra cómo puede manejarse la entrada de datos en diferentes escenarios usando funciones del sistema como select().</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <div class="code-block">
                    <pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/select.h&gt;

#define BUFFER_SIZE 128

int main() {
    char buffer[BUFFER_SIZE];
    int n;
    int file = open("salida.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
    
    if (file &lt; 0) {
        perror("No se pudo abrir el archivo");
        return 1;
    }
    
    printf("Modo de E/S:\n");
    printf("1. Bloqueante (espera entrada del usuario)\n");
    printf("2. No bloqueante (verifica si hay entrada sin esperar)\n");
    printf("Selecciona una opción: ");
    
    int modo;
    if (scanf("%d", &modo) != 1) {
        printf("Entrada no válida.\n");
        close(file);
        return 1;
    }
    
    while (getchar() != '\n'); // Limpiar el búfer de entrada
    
    if (modo == 1) {
        // Modo bloqueante
        printf("Escribe algo (bloqueante): ");
        if (fgets(buffer, BUFFER_SIZE, stdin) == NULL) {
            perror("Error al leer entrada");
            close(file);
            return 1;
        }
        
        if (write(file, buffer, strlen(buffer)) == -1) {
            perror("Error al escribir en el archivo");
        } else {
            printf("Se escribió en el archivo: %s", buffer);
        }
        
    } else if (modo == 2) {
        // Modo no bloqueante usando select()
        printf("Esperando entrada por 5 segundos... (no bloqueante)\n");
        
        fd_set fds;
        struct timeval timeout;
        
        FD_ZERO(&fds);
        FD_SET(STDIN_FILENO, &fds);
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        
        int ready = select(STDIN_FILENO + 1, &fds, NULL, NULL, &timeout);
        
        if (ready == -1) {
            perror("Error en select()");
        } else if (ready == 0) {
            printf("Tiempo de espera agotado. No se ingresó nada.\n");
        } else {
            if (fgets(buffer, BUFFER_SIZE, stdin) == NULL) {
                perror("Error al leer entrada");
            } else {
                if (write(file, buffer, strlen(buffer)) == -1) {
                    perror("Error al escribir en el archivo");
                } else {
                    printf("Se escribió en el archivo: %s", buffer);
                }
            }
        }
    } else {
        printf("Opción no válida.\n");
    }
    
    close(file);
    return 0;
}</pre>
                    <div class="code-caption">Código 4. Ejemplo de entrada de datos en modo bloqueante y no bloqueante</div>
                </div>
            </div>
        </div>
        
        <!-- Sección 5.2.1 -->
        <div class="section" id="seccion-5-2-1">
            <div class="section-header">
                <div class="section-number">5.2.1</div>
                <div class="section-title">Objetivos del Software de E/S</div>
            </div>
            <div class="content">
                <p>El principal objetivo en la parte del software de E/S (entrada y salida) es mantener la <span class="highlight">independencia de los dispositivos</span>, es decir, permitir que la información proveniente de cualquier dispositivo pueda ser utilizada por un programa sin importar el origen físico del archivo. Por ejemplo, un archivo almacenado en un DVD, memoria USB o CD-ROM debe poder ser accedido sin especificar el tipo de hardware de origen. "El sistema operativo se encarga de proporcionar los comandos necesarios para realizar operaciones de lectura y escritura en los dispositivos requeridos".</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <p>Asimismo, es posible ejecutar comandos que provienen tanto del teclado como de archivos en disco. Un ejemplo típico en sistemas Unix/Linux es:</p>
                
                <div class="code-block">
                    <pre>gcc &lt;entrada&gt;.c -o salida.exe</pre>
                    <div class="code-caption">Este comando compila un archivo .c y genera un ejecutable.</div>
                </div>
                
                <p>Por otro lado, la <span class="highlight">denominación uniforme</span> es un objetivo importante. El nombre de un archivo debe depender únicamente de una cadena de caracteres o un identificador numérico, permitiendo ubicarlo sin importar el dispositivo. Por ejemplo, si se desea copiar un archivo al directorio /Gael/ast/respaldo/lunes, basta con conocer esa dirección, independientemente del dispositivo de origen.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <p>El <span class="highlight">manejo de errores de E/S</span> también se considera a nivel de hardware. Esto significa que, idealmente, el controlador debería corregir errores automáticamente. En muchos casos, un error puede solucionarse simplemente repitiendo la operación de lectura.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <p>Las <span class="highlight">operaciones asíncronas</span> son comúnmente utilizadas en E/S debido a su flexibilidad: permiten iniciar una transferencia y continuar con otras tareas mientras se espera una interrupción. En contraste, las operaciones de bloqueo suspenden la ejecución del programa hasta que los datos estén disponibles, lo cual puede simplificar el desarrollo de software.</p>
                <p class="citation">(Stallings, 2020)</p>
                
                <p>El uso de <span class="highlight">buffers</span> permite almacenar temporalmente datos entre el origen y destino, evitando sub o sobrecargas y mejorando el rendimiento general de las operaciones de E/S. Este mecanismo es fundamental en la gestión eficiente de recursos.</p>
                <p class="citation">(Silberschatz et al., 2018)</p>
                
                <p>Finalmente, es importante distinguir entre <span class="highlight">dispositivos compartidos y dispositivos dedicados</span>. Los primeros pueden ser utilizados simultáneamente por varios usuarios sin conflicto (como discos duros), mientras que los segundos (como una impresora) requieren acceso exclusivo y secuencial.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
            </div>
        </div>
        
        <!-- Sección 5.2.2 -->
        <div class="section" id="seccion-5-2-2">
            <div class="section-header">
                <div class="section-number">5.2.2</div>
                <div class="section-title">E/S Programadas</div>
            </div>
            <div class="content">
                <p>"Aunque existen tres maneras en las que podemos llevar a cabo E/S (E/S quiere decir: entrada y salida), esta es la forma más simple en que podemos hacerlo".</p>
                <p class="citation">(Tanenbaum & Bos, 2015, p. 193)</p>
                
                <p>La E/S programada implica que todo el proceso de entrada y salida es gestionado directamente por el procesador (CPU) y se ejecuta a nivel de kernel. A modo de ejemplo, consideremos un proceso que envía la cadena "HOLA" a una impresora.</p>
                
                <h3>Flujo del Proceso</h3>
                <ol>
                    <li><strong>Ensamblado en el espacio de usuario:</strong> El proceso primero ensambla la cadena en un búfer en el espacio de usuario. Este paso se ilustra en la Figura 2.</li>
                    <div class="figure-container">
                        <div class="figura">
                            <img src="FIGURA2.jpg" alt="Figura 2: Etapas del proceso de E/S programada en el espacio de usuario." class="imagen-figura2"/>
                        </div>
                        <div class="figure-caption">Figura 2. Etapas del proceso de E/S programada en el espacio de usuario.</div>
                    </div>
                    <li><strong>Llamada al sistema:</strong> Luego, se realiza una llamada al sistema para abrir la impresora:
                        <ul>
                            <li>Si el dispositivo no está disponible, la llamada falla, devuelve un código de error y el proceso espera hasta que esté listo.</li>
                            <li>Si está disponible, se realiza una nueva llamada al sistema para enviar la cadena a imprimir.</li>
                        </ul>
                    </li>
                    <li><strong>Copia al espacio de kernel:</strong> El sistema operativo copia el búfer desde el espacio de usuario al espacio de kernel, permitiendo el acceso directo desde el sistema. Esto se muestra en la Figura 3.</li>
                        <ul>
                            <li>Se verifica si la impresora está lista; si no lo está, se espera.</li>
                            <li>Se imprime el primer carácter y se marca el siguiente.</li>
                        </ul>
                    <div class="figure-container">
                        <div class="figura">
                            <img src="FIGURA3.jpg" alt="Figura 3: Etapas del proceso de E/S programada traslado al Kernel." class="imagen-figura3"/>
                        </div>
                        <div class="figure-caption">Figura 3. Etapas del proceso de E/S programada traslado al Kernel.</div>
                    </div>
                    <li><strong>Impresión carácter por carácter:</strong> Finalmente, el sistema operativo comprueba repetidamente si la impresora está lista para recibir el siguiente carácter. Si lo está, continúa la impresión. Este ciclo se repite hasta que toda la cadena ha sido enviada, como se observa en la Figura 4.</li>
                    <div class="figure-container">
                        <div class="figura">
                            <img src="FIGURA4.jpg" alt="Figura 4: Etapas del proceso de E/S programada procesamiento carácter por carácter." class="imagen-figura4"/>
                        </div>
                        <div class="figure-caption">Figura 4. Etapas del proceso de E/S programada procesamiento carácter por carácter.</div>
                    </div>
                </ol>
                
                <h4>Síntesis del Proceso</h4>
                <ol>
                    <li>Copia de los datos al espacio de kernel.</li>
                    <li>Bucle que imprime un carácter a la vez.</li>
                    <li>Repetición hasta completar la impresión de toda la cadena.</li>
                </ol>
                
                <h3>Ejemplo de Código</h3>
                <p>Con el Código 5 hecho en C ejemplificamos los pasos dichos anteriormente una simulación de E/S Programada.</p>
                
                <div class="code-block">
                    <pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int READY = 1;

// Simulación de registros de hardware
// Prototipos
int nivelde_usuario();
int nivelKernel(char* p, int caracteres);

int main() {
    nivelde_usuario();
    return 0;
}

int nivelde_usuario() {
    char cadena_imprimir[100];
    int numero_caracteres;
    
    printf("Introduzca la cadena a imprimir: ");
    fgets(cadena_imprimir, sizeof(cadena_imprimir), stdin); //En este caso sera hola
    
    // Elimina el salto de línea final si existe
    cadena_imprimir[strcspn(cadena_imprimir, "\n")] = '\0';
    
    printf("Impresora no disponible...\n");
    sleep(2); // Simula espera
    printf("Impresora disponible\n");
    
    numero_caracteres = strlen(cadena_imprimir);
    
    // Llamada simulada al sistema operativo (nivel de kernel)
    nivelKernel(cadena_imprimir, numero_caracteres);
    
    return 0;
}

int nivelKernel(char* p, int caracteres) {
    char registro_datos_impresora;
    
    for (int i = 0; i &lt; caracteres; i++) {
        while (READY != 0 ) {
            printf("Esperando a que la impresora este lista \n");
            usleep(500000); // Simula tiempo de impresión
            READY = 0;
        }
        
        // Simula el envío del carácter a la impresora
        registro_datos_impresora = p[i];
        printf("Imprimiendo: %c\n", registro_datos_impresora);
        usleep(500000); // Simula tiempo de impresión
        READY = 1;
    }
    
    return 0;
}</pre>
                    <div class="code-caption">Código 5. Simulación en código de una E/S programada</div>
                </div>
                
                <h3>Ventajas y Desventajas</h3>
                <p>La principal desventaja de este enfoque es que el procesador queda completamente ocupado durante la operación de E/S, lo que es ineficiente en sistemas donde el CPU debe atender múltiples procesos. No obstante, en sistemas embebidos, donde las tareas están claramente definidas y controladas, esta técnica sigue siendo viable por su simplicidad y bajo costo computacional.</p>
                <p class="citation">(Silberschatz, Galvin, & Gagne, 2018)</p>
            </div>
        </div>
        
        <!-- Sección 5.2.3 -->
        <div class="section" id="seccion-5-2-3">
            <div class="section-header">
                <div class="section-number">5.2.3</div>
                <div class="section-title">E/S Manejadas por Interrupciones</div>
            </div>
            <div class="content">
                <p>Supongamos que una impresora tiene una velocidad de impresión de 100 caracteres por segundo, es decir, necesita 10 milisegundos para imprimir cada carácter. Aunque este tiempo puede parecer breve, es suficiente para que el procesador (CPU) aproveche ese intervalo ejecutando otras tareas, logrando así un mejor aprovechamiento del tiempo de espera entre impresiones.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <p>A diferencia de la E/S programada, en la E/S manejada por interrupciones el procesador no permanece ocioso esperando a que el dispositivo esté disponible. En su lugar, ejecuta otros procesos y solo interrumpe su actividad cuando el dispositivo (como la impresora) indica que está listo para recibir el siguiente carácter.</p>
                
                <h3>Funcionamiento General</h3>
                <p>El flujo general es similar al de la E/S programada en cuanto a los primeros pasos:</p>
                <ol>
                    <li>El proceso construye la cadena a imprimir en el espacio de usuario.</li>
                    <li>Se copia el búfer al espacio de Kernel.</li>
                    <li>Se verifica si la impresora está disponible.</li>
                </ol>
                
                <p>Pero a partir del paso 3, el comportamiento cambia:</p>
                <ul>
                    <li>En lugar de esperar activamente, el sistema operativo llama al planificador de tareas para que ejecute otro proceso mientras la impresora termina de imprimir el carácter actual.</li>
                    <li>Una vez que el carácter ha sido impreso, se genera una interrupción, provocando que el CPU detenga temporalmente el proceso actual, guarde su estado y atienda el servicio de interrupción de la impresora.</li>
                    <li>Dentro de este procedimiento de servicio, el sistema verifica si aún quedan caracteres por imprimir. Si es así, continúa el ciclo. Si no, finaliza la operación de E/S.</li>
                </ul>
                
                <p>Este mecanismo mejora significativamente la eficiencia del sistema, especialmente en entornos multitarea.</p>
                
                <h3>Fragmento de Código Adaptado</h3>
                <p>A continuación, se muestra el Código 6, un fragmento de código que ejemplifica la lógica de interrupciones, simulando el comportamiento de la impresora mientras se ejecutan otras tareas:</p>
                
                <div class="code-block">
                    <pre>char registro_datos_impresora;

for (int i = 0; i &lt; caracteres; i++) {
    while (READY != 0) {
        printf("Habilitando interrupción\n");
        printf("Ejecutando otro proceso\n");
        usleep(500000); // Simula tiempo de espera mientras se ejecuta otro proceso
        READY = 0; // Simula que la impresora ya no está lista
    }
    
    // Envío del carácter cuando READY == 0
    registro_datos_impresora = p[i];
    printf("Imprimiendo: %c\n", registro_datos_impresora);
    usleep(500000); // Simula impresión del carácter
    READY = 1; // Simula que la impresora vuelve a estar lista
}</pre>
                    <div class="code-caption">Código 6. E/S controlada por interrupciones para mayor eficiencia</div>
                </div>
                
                <p>Este fragmento ilustra cómo el sistema puede continuar con otras tareas y ser interrumpido únicamente cuando la impresora esté lista para procesar el siguiente carácter, simulando el comportamiento del servicio de interrupción.</p>
                
                <h3>Conclusión</h3>
                <p>La E/S controlada por interrupciones representa una mejora notable sobre la E/S programada, ya que optimiza el uso del procesador permitiéndole ejecutar otros procesos mientras espera por la disponibilidad del dispositivo. Esta técnica es ampliamente utilizada en sistemas operativos modernos para manejar dispositivos como discos, tarjetas de red o impresoras.</p>
                <p class="citation">(Silberschatz, Galvin, & Gagne, 2018)</p>
            </div>
        </div>
        
        <!-- Sección 5.2.4 -->
        <div class="section" id="seccion-5-2-4">
            <div class="section-header">
                <div class="section-number">5.2.4</div>
                <div class="section-title">E/S usando DMA</div>
            </div>
            <div class="content">
                <p>Una desventaja clara de la E/S controlada por interrupciones es que se genera una interrupción por cada carácter enviado, lo cual implica un uso considerable del tiempo del procesador. Para mitigar este problema, se emplea el mecanismo de DMA (acceso directo a memoria), en el cual un controlador especializado gestiona la transferencia de datos entre la memoria principal y el dispositivo (como una impresora), sin requerir la intervención constante de la CPU.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
                
                <p>En este modelo, el controlador DMA asume las tareas que normalmente realizaría el procesador en los métodos de E/S programada. Si bien esta solución exige hardware adicional, su principal beneficio es que la CPU queda libre para realizar otras operaciones mientras se completa la transferencia de datos.</p>
                
                <h3>Funcionamiento General</h3>
                <p>El proceso de impresión mediante DMA consta de dos fases principales:</p>
                
                <h4>Fase 1: Inicio de la Operación</h4>
                <p>Código ejecutado cuando se realiza la llamada al sistema para iniciar la impresión, tal como lo muestra el Código 7.</p>
                
                <div class="code-block">
                    <pre>copiar_del_usuario(bufer, p, cuenta);
establecer_controlador_DMA();
planificador();</pre>
                    <div class="code-caption">Código 7. Código asociado al inicio de la operación</div>
                </div>
                
                <h4>Fase 2: Finalización</h4>
                <p>Código que se ejecuta en el procedimiento de servicio de interrupciones, una vez que el DMA ha completado su tarea, como lo muestra el Código 8.</p>
                
                <div class="code-block">
                    <pre>reconocer_interrupcion();
desbloquear_usuario();
regresar_de_interrupcion();</pre>
                    <div class="code-caption">Código 8. Procedimiento que se activa tras la interrupción del DMA</div>
                </div>
                
                <h3>Ventajas y Consideraciones</h3>
                <p>El uso de DMA ofrece una ventaja fundamental: reduce drásticamente el número de interrupciones, pasando de una por carácter (como en E/S por interrupciones) a una sola por cada búfer completo. Este cambio es especialmente beneficioso cuando se trabaja con grandes volúmenes de datos o cuando las interrupciones son costosas en tiempo de procesamiento.</p>
                
                <p>Sin embargo, el DMA no siempre es la mejor opción:</p>
                <ul>
                    <li>Si el controlador DMA no puede manejar el dispositivo a su velocidad máxima.</li>
                    <li>Si la CPU está inactiva o tiene pocos procesos pendientes.</li>
                </ul>
                
                <p>En tales casos, puede ser preferible utilizar E/S por interrupciones o incluso programada, dependiendo del contexto del sistema. Aun así, en la mayoría de los escenarios multitarea, el uso de DMA resulta más eficiente y deseable.</p>
                <p class="citation">(Tanenbaum & Bos, 2015)</p>
            </div>
        </div>
        
        <!-- Actividad de Aprendizaje -->
        <div class="activity-card">
            <div class="activity-title">Actividad de Aprendizaje 2: Principios del Software de E/S</div>
            <p>Pon a prueba tus conocimientos sobre los objetivos y métodos del software de entrada y salida.</p>
            <a href="actividad_5_2.html" class="activity-btn">
                <i class="fas fa-pencil-alt"></i> Realizar Actividad
            </a>
        </div>
        
        <!-- Navegación -->
        <div class="nav-buttons">
            <a href="5.1.html" class="nav-btn"><i class="fas fa-arrow-left"></i> Volver a 5.1: Hardware de E/S</a>
            <a href="5.3.html" class="nav-btn">Continuar a 5.3: Capas de Software <i class="fas fa-arrow-right"></i></a>
        </div>
        
        <footer>
            <p>Sistemas Operativos - Unidad 5: Dispositivos de Entrada y Salida</p>
            <p>Desarrollado para fines educativos - © 2025 | Referencias: Tanenbaum & Bos (2015), Silberschatz et al. (2018), Stallings (2020)</p>
        </footer>
    </div>

    <script>
        // --- VARIABLES GLOBALES ---
        // Declara una variable para mantener el estado del menú lateral (abierto o cerrado).
        let sidebarOpen = false;

        // --- LÓGICA DEL MENÚ LATERAL (SIDEBAR) ---
        // Obtiene referencias a los elementos del DOM que se van a manipular.
        const menuToggle = document.getElementById('menuToggle'); // El botón de hamburguesa.
        const sidebarNav = document.getElementById('sidebarNav'); // El menú de navegación.
        const sidebarOverlay = document.getElementById('sidebarOverlay'); // El fondo oscuro.

        // Función para abrir o cerrar el menú lateral.
        function toggleSidebar() {
            // Invierte el valor booleano de sidebarOpen.
            sidebarOpen = !sidebarOpen;
            
            if (sidebarOpen) {
                // Si el menú se va a abrir:
                sidebarNav.classList.add('active'); // Muestra el menú añadiendo la clase 'active'.
                sidebarOverlay.classList.add('active'); // Muestra el fondo oscuro.
                menuToggle.classList.add('active'); // Cambia el estilo del botón.
                menuToggle.innerHTML = '<i class="fas fa-times"></i>'; // Cambia el ícono a una 'X'.
                document.body.style.overflow = 'hidden'; // Impide el scroll en el cuerpo de la página.
            } else {
                // Si el menú se va a cerrar:
                sidebarNav.classList.remove('active'); // Oculta el menú quitando la clase 'active'.
                sidebarOverlay.classList.remove('active'); // Oculta el fondo oscuro.
                menuToggle.classList.remove('active'); // Restaura el estilo del botón.
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>'; // Restaura el ícono de hamburguesa.
                document.body.style.overflow = 'auto'; // Vuelve a permitir el scroll.
            }
            
            // Ajusta el espaciado del contenedor principal para que no quede debajo del menú.
            updateContainerSpacing();
        }

        // Asigna la función toggleSidebar al evento 'click' del botón y del fondo oscuro.
        menuToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        // Cierra el menú en dispositivos móviles cuando se hace clic en un enlace de navegación.
        document.querySelectorAll('.nav-item[data-section]').forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth <= 768) { // Si es una pantalla pequeña.
                    toggleSidebar(); // Cierra el menú.
                }
            });
        });

        // --- AJUSTE DINÁMICO DEL CONTENEDOR ---
        // Función que ajusta los márgenes del contenido principal dependiendo del tamaño de la ventana y si el menú está abierto.
        function updateContainerSpacing() {
            const container = document.querySelector('.container');
            
            if (window.innerWidth <= 768) {
                // En móviles, usa márgenes fijos y reducidos.
                container.style.marginLeft = '20px';
                container.style.marginRight = '20px';
                container.style.padding = '10px';
            } else if (sidebarOpen && window.innerWidth > 768) {
                // En escritorio con el menú abierto, añade un margen izquierdo grande.
                container.style.marginLeft = '370px'; // 280px del menú + 90px de espacio.
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            } else {
                // En otros casos (escritorio, menú cerrado), usa márgenes normales.
                container.style.marginLeft = '90px';
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            }
        }

        // --- RESALTADO DE SECCIÓN ACTIVA EN EL MENÚ (SCROLLSPY) ---
        // Función para detectar qué sección está visible y resaltar el enlace correspondiente en el menú.
        function updateActiveSection() {
            const sections = document.querySelectorAll('.section'); // Obtiene todas las secciones de contenido.
            const navItems = document.querySelectorAll('.nav-item[data-section]'); // Obtiene todos los enlaces del menú.
            
            let currentSection = '';
            
            // Itera sobre cada sección para ver su posición en la pantalla.
            sections.forEach(section => {
                const rect = section.getBoundingClientRect(); // Obtiene las coordenadas de la sección.
                // Si la sección está cerca de la parte superior de la ventana, se considera la actual.
                if (rect.top <= 150 && rect.bottom >= 150) {
                    currentSection = section.id.replace('seccion-', ''); // Extrae el identificador de la sección.
                    if (section.id === 'introduccion') {
                        currentSection = 'introduccion';
                    }
                }
            });
            
            // Itera sobre los enlaces del menú para aplicar la clase 'active'.
            navItems.forEach(item => {
                item.classList.remove('active'); // Quita la clase 'active' de todos los enlaces.
                if (item.dataset.section === currentSection) {
                    item.classList.add('active'); // Añade la clase 'active' solo al enlace de la sección actual.
                }
            });
        }

        // --- INDICADOR DE PROGRESO DE LECTURA ---
        // Función que actualiza la barra de progreso en la parte superior.
        function updateReadingProgress() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop; // Cuánto se ha desplazado el usuario.
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight; // La altura total desplazable.
            const scrolled = (winScroll / height) * 100; // Calcula el porcentaje de desplazamiento.
            document.getElementById('progressBar').style.width = scrolled + '%'; // Asigna el porcentaje al ancho de la barra.
        }

        // --- BOTÓN DE "IR ARRIBA" ---
        const scrollToTopBtn = document.getElementById('scrollToTop');

        // Función para mostrar u ocultar el botón de "ir arriba".
        function toggleScrollToTopBtn() {
            if (window.pageYOffset > 300) { // Si el usuario ha bajado más de 300px.
                scrollToTopBtn.classList.add('visible'); // Muestra el botón.
            } else {
                scrollToTopBtn.classList.remove('visible'); // Oculta el botón.
            }
        }

        // Asigna un evento de clic al botón para que desplace la página al inicio suavemente.
        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth' // Animación de desplazamiento suave.
            });
        });

        // --- EVENT LISTENERS PRINCIPALES ---
        // Se ejecutan cada vez que el usuario hace scroll.
        window.addEventListener('scroll', () => {
            updateActiveSection();
            updateReadingProgress();
            toggleScrollToTopBtn();
        });

        // --- DESPLAZAMIENTO SUAVE PARA ENLACES DE ANCLA ---
        // Mejora el comportamiento de los enlaces internos (ej: href="#seccion-1").
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault(); // Previene el comportamiento de salto por defecto.
                const target = document.querySelector(this.getAttribute('href')); // Encuentra el elemento de destino.
                
                if (target) {
                    const offsetTop = target.offsetTop - 100; // Calcula la posición con un margen de 100px desde arriba.
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth' // Desplaza la ventana suavemente.
                    });
                }
            });
        });

        // Se ejecuta cuando se cambia el tamaño de la ventana.
        window.addEventListener('resize', () => {
            // Si el menú está abierto y la ventana se agranda a más de 768px, cierra el menú.
            if (window.innerWidth > 768 && sidebarOpen) {
                toggleSidebar();
            }
            // Reajusta el espaciado del contenedor.
            updateContainerSpacing();
        });

        // --- INICIALIZACIÓN ---
        // Se ejecuta cuando el contenido HTML de la página ha sido completamente cargado.
        document.addEventListener('DOMContentLoaded', function() {
            // Llama a las funciones de actualización para establecer el estado inicial correcto.
            updateActiveSection();
            updateReadingProgress();
            updateContainerSpacing();
            
            // En móviles, asegura que el menú empiece cerrado.
            if (window.innerWidth <= 768) {
                sidebarNav.classList.remove('active');
            }
        });

        // --- ATAJOS DE TECLADO ---
        document.addEventListener('keydown', (e) => {
            // Si se presiona la tecla 'Escape' y el menú está abierto, lo cierra.
            if (e.key === 'Escape' && sidebarOpen) {
                toggleSidebar();
            }
            
            // Si se presiona la tecla 'M', abre o cierra el menú.
            if (e.key === 'm' || e.key === 'M') {
                if (!e.ctrlKey && !e.altKey) { // Se asegura de que no se esté usando un modificador como Ctrl o Alt.
                    toggleSidebar();
                }
            }
        });
    </script>
</body>
</html>