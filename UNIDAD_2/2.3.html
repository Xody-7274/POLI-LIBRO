<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.3 Comunicación entre procesos</title>
    <link rel="icon" type="image/png" href="logoescom.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --gray: #95a5a6;
            --success: #2ecc71;
            --warning: #f39c12;
            --card-bg: rgba(255, 255, 255, 0.05);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a3a, #2c3e50);
            color: var(--light);
            min-height: 100vh;
            line-height: 1.7;
        }

        .floating-home-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 1.5rem;
        }

        .floating-home-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.4);
        }

        .sidebar-nav {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
            transition: transform 0.3s ease;
            transform: translateX(-100%);
            overflow-y: auto;
        }

        .sidebar-nav.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(52, 152, 219, 0.1);
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        }

        .sidebar-title {
            font-size: 1.2rem;
            color: var(--secondary);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .sidebar-subtitle {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .nav-sections {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 15px;
        }

        .nav-section-title {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
            margin-bottom: 10px;
        }

        .nav-item {
            display: block;
            padding: 12px 20px;
            color: var(--light);
            text-decoration: none;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-left-color: var(--secondary);
            padding-left: 25px;
        }

        .nav-item.active {
            background: rgba(52, 152, 219, 0.2);
            border-left-color: var(--secondary);
            color: var(--secondary);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--primary);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1001;
            font-size: 1.2rem;
        }

        .menu-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        .menu-toggle.active {
            background: var(--accent);
        }

        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 998;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--success));
            width: 0%;
            transition: width 0.1s ease;
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            transition: margin-left 0.3s ease, margin-right 0.3s ease;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .breadcrumb {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            color: var(--gray);
            font-size: 1.1rem;
        }
        
        .breadcrumb a {
            color: var(--secondary);
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .breadcrumb a:hover {
            color: white;
            text-decoration: underline;
        }
        
        .breadcrumb span {
            margin: 0 10px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: white;
        }
        
        .subtitle {
            font-size: 1.8rem;
            color: var(--secondary);
            margin-bottom: 20px;
            font-weight: 300;
            text-align: center;
        }
        
        .intro {
            max-width: 900px;
            margin: 0 auto 40px;
            padding: 25px;
            background: var(--card-bg);
            border-radius: 15px;
            border-left: 4px solid var(--secondary);
            text-align: justify;
        }
        
        .section {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            scroll-margin-top: 100px;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--secondary);
        }
        
        .section-number {
            font-size: 2.2rem;
            font-weight: bold;
            color: var(--secondary);
            margin-right: 15px;
            min-width: 120px;
        }
        
        .section-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: white;
        }
        
        .content {
            padding: 0 10px;
        }
        
        .content h3 {
            font-size: 1.5rem;
            color: var(--secondary);
            margin: 30px 0 15px;
            padding-left: 10px;
            border-left: 3px solid var(--accent);
        }

        .content h4 {
            font-size: 1.3rem;
            color: var(--warning);
            margin: 25px 0 12px;
            padding-left: 8px;
        }
        
        .content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .content ul, .content ol {
            padding-left: 30px;
            margin: 20px 0;
        }
        
        .content li {
            margin-bottom: 12px;
        }
        
        .highlight {
            background: rgba(231, 76, 60, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .citation {
            font-style: italic;
            color: var(--gray);
            margin: 5px 0 15px 20px;
            border-left: 2px solid var(--secondary);
            padding-left: 10px;
        }
        
        .quote-box {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--secondary);
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
            font-style: italic;
            color: var(--light);
        }

        .quote-box .citation {
            border-left: none;
            margin: 10px 0 0 0;
            padding-left: 0;
        }
        
        .table-container {
            max-width: 800px;
            margin: 30px auto;
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.2);
        }
        
        th {
            background: var(--primary);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .table-caption {
            text-align: center;
            padding: 10px;
            font-style: italic;
            color: var(--gray);
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        
        .nav-btn {
            display: inline-flex;
            align-items: center;
            background: var(--secondary);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
        }
        
        .nav-btn i {
            margin: 0 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 60px;
            padding: 30px;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
            z-index: 999;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: #c0392b;
            transform: translateY(-3px);
        }
        
        .activity-card {
            background: rgba(46, 204, 113, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 40px 0;
            border-left: 4px solid var(--success);
            text-align: center;
        }

        .activity-title {
            font-size: 1.8rem;
            color: var(--success);
            margin-bottom: 20px;
        }

        .activity-btn {
            display: inline-block;
            background: var(--success);
            color: white;
            padding: 15px 35px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .activity-btn:hover {
            background: #27ae60;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }

        @media (max-width: 768px) {
            .sidebar-nav {
                width: 100%;
            }

            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1.4rem;
            }
            
            .section-title {
                font-size: 1.5rem;
            }
            
            .section-number {
                min-width: 100px;
                font-size: 1.8rem;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
                text-align: center;
                justify-content: center;
            }

            .floating-home-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="reading-progress">
        <div class="reading-progress-bar" id="progressBar"></div>
    </div>

    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <a href="index.html" class="floating-home-btn" title="Ir al índice de unidades">
        <i class="fas fa-home"></i>
    </a>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <nav class="sidebar-nav" id="sidebarNav">
        <div class="sidebar-header">
            <div class="sidebar-title">2.3 Comunicación entre procesos</div>
            <div class="sidebar-subtitle">Administración de procesos</div>
        </div>
        
        <div class="nav-sections">
            <div class="nav-section">
                <div class="nav-section-title">Navegación</div>
                <a href="#inicio" class="nav-item">
                    <i class="fas fa-rocket"></i> Inicio del Tema
                </a>
                <a href="index.html" class="nav-item">
                    <i class="fas fa-arrow-left"></i> Menú de Unidad 2
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Contenido</div>
                <a href="#seccion-2-3-1" class="nav-item" data-section="2-3-1">
                    <i class="fas fa-memory"></i> 2.3.1 Memoria compartida
                </a>
                <a href="#seccion-2-3-2" class="nav-item" data-section="2-3-2">
                    <i class="fas fa-envelope"></i> 2.3.2 Paso de mensajes
                </a>
                <a href="#seccion-2-3-3" class="nav-item" data-section="2-3-3">
                    <i class="fas fa-pipe"></i> 2.3.3 Tuberías
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Recursos</div>
                <a href="actividad_2.3.html" class="nav-item">
                    <i class="fas fa-tasks"></i> Actividad de aprendizaje
                </a>
                <a href="2.4.html" class="nav-item">
                    <i class="fas fa-arrow-right"></i> Siguiente: Sincronización entre procesos/hilos
                </a>
            </div>
        </div>
    </nav>

    <button class="scroll-to-top" id="scrollToTop">
        <i class="fas fa-chevron-up"></i>
    </button>

    <div class="container">
        <header id="inicio">
            <div class="breadcrumb">
                <a href="index.html"><i class="fas fa-home"></i> Inicio</a>
                <span>/</span>
                <a href="index.html">Unidad 2</a>
                <span>/</span>
                <span>2.3 Comunicación entre procesos</span>
            </div>
            <h1>2.3 Comunicación entre procesos</h1>
            <div class="subtitle">Administración de procesos</div>
        </header>
        
        <div class="intro">
            <p>La comunicación entre procesos (IPC, por sus siglas en inglés) consiste en mecanismos que permiten a los procesos independientes compartir datos y sincronizar sus actividades. Esta función es fundamental en los sistemas operativos modernos, ya que permite la ejecución coordinada de aplicaciones y servicios complejos.</p>
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

            <br>
            <h4>¿Por qué es Necesaria la IPC?</h4>
            <p>La necesidad de la IPC surge de varias situaciones en un sistema operativo:</p>

            <ul>
                <li><strong>Cooperación entre Procesos:</strong> Muchos programas se diseñan como un conjunto de procesos cooperativos, donde cada uno realiza una parte específica de una tarea mayor. Por ejemplo, en un entorno de desarrollo, un proceso puede compilar código mientras otro lo enlaza y un tercero lo ejecuta.</li>
                <li><strong>Compartición de Información:</strong> Los procesos a menudo necesitan acceder y compartir los mismos datos o recursos. Sin mecanismos de IPC, cada proceso tendría su propia copia de los datos, lo que sería ineficiente y podría llevar a inconsistencias.</li>
                <li><strong>Modularidad:</strong> La IPC permite que los programas se dividan en módulos independientes (procesos), lo que facilita el desarrollo, depuración y mantenimiento. Cada módulo puede ejecutarse en su propio espacio de memoria, aumentando la robustez del sistema.</li>
                <li><strong>Distribución de Tareas:</strong> En sistemas con múltiples procesadores o núcleos, la IPC es vital para distribuir la carga de trabajo entre ellos, permitiendo que diferentes procesos se ejecuten en paralelo y aprovechen el hardware al máximo.</li>
                <li><strong>Sincronización:</strong> Además de intercambiar datos, los procesos a menudo necesitan sincronizarse para asegurar que ciertos eventos ocurran en un orden específico o para proteger recursos compartidos de accesos concurrentes no deseados (condiciones de carrera).</li>
            </ul>

            <br>
            <h4>Componentes Clave de la IPC</h4>
            <p>Para que la comunicación entre procesos sea efectiva, los sistemas operativos ofrecen diversas herramientas y conceptos:</p>

            <ul>
                <li><strong>Paso de mensajes:</strong> La comunicación entre procesos se realiza mediante el envío y recepción de mensajes. Este método es especialmente útil cuando los procesos no comparten el mismo espacio de memoria.</li>
                <li><strong>Memoria Compartida:</strong> Los procesos establecen una región de memoria a la que ambos tienen acceso. Esta es una forma muy eficiente de comunicación, pero requiere que los procesos coordinen su acceso a la memoria para evitar conflictos.</li>
                <li><strong>Sincronización:</strong> Se emplean mecanismos como semáforos, mutex y variables de condición para coordinar la ejecución de los procesos, garantizando un acceso seguro a los recursos compartidos y asegurando que los procesos solo avancen cuando se cumplan ciertas condiciones.</li>
                <li><strong>Pipes (Tuberías):</strong> Un mecanismo para la comunicación unidireccional o bidireccional entre procesos relacionados (típicamente padre-hijo).</li>
                <li><strong>Colas de Mensajes:</strong> Permiten que los mensajes se almacenen temporalmente hasta que el proceso receptor esté listo para procesarlos, desacoplando al emisor y al receptor.</li>
                <li><strong>Sockets:</strong> Son una herramienta que permite la comunicación entre procesos, ya sea que se ejecuten en el mismo equipo o en distintos dispositivos conectados a través de una red.</li>
            </ul>

            <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

            <div class="quote-box">
                "La implementación eficiente de estos mecanismos es una parte crucial del diseño de un sistema operativo, ya que impacta directamente en el rendimiento y la fiabilidad de las aplicaciones concurrentes y distribuidas."
            </div>
        </div>
        
        <div class="section" id="seccion-2-3-1">
            <div class="section-header">
                <div class="section-number">2.3.1</div>
                <div class="section-title">Memoria compartida</div>
            </div>
            <div class="content">
                <p>La memoria compartida es un mecanismo de comunicación entre procesos (IPC) que permite a varios procesos acceder simultáneamente a una misma área de memoria. Esta técnica se caracteriza por su alta eficiencia y velocidad en el intercambio de datos, lo que la convierte en una opción eficaz para la coordinación entre procesos en los sistemas operativos.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <h3>Importancia de la Memoria Compartida</h3>
                <p>Su importancia radica en los siguientes puntos:</p>

                <h4>1. Velocidad de Comunicación Superior:</h4>
                <p>La memoria compartida permite que los procesos accedan directamente a una región común de memoria, evitando copias de datos y llamadas al sistema costosas, lo que la convierte en el método más rápido de comunicación entre procesos.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <h4>2. Eficiencia en el Uso de Recursos:</h4>
                <p>Al compartir la misma región de memoria, se evita la duplicación de datos y se optimiza el uso de recursos, especialmente útil en aplicaciones que manejan grandes volúmenes de datos.</p>
                
                <div class="citation">(Silberschatz et al., 2018).</div>

                <h4>3. Facilita la Coordinación Compleja:</h4>
                <p>La memoria compartida es ideal para escenarios donde procesos colaboran estrechamente, accediendo a estructuras de datos complejas, como en procesamiento de imágenes o video.</p>
                
                <div class="citation">(Silberschatz et al., 2018).</div>

                <h4>4. Base para Otros Mecanismos de IPC:</h4>
                <p>Dado que la memoria compartida requiere sincronización para evitar condiciones de carrera, suele combinarse con semáforos o mutex para asegurar la integridad de los datos.</p>
                
                <div class="citation">(Silberschatz et al., 2018).</div>

                <h4>5. Aplicaciones de Alto Rendimiento:</h4>
                <p>Es el mecanismo preferido en aplicaciones que demandan alta eficiencia y baja latencia, como bases de datos, simulaciones, juegos y servidores web.</p>
                
                <div class="citation">(Silberschatz et al., 2018).</div>

                <div class="quote-box">
                    "La memoria compartida es esencial en la comunicación entre procesos por su rapidez y eficiencia, aunque necesita mecanismos de sincronización para mantener la coherencia de los datos"
                    <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>
                </div>
            </div>
        </div>
        
        <div class="section" id="seccion-2-3-2">
            <div class="section-header">
                <div class="section-number">2.3.2</div>
                <div class="section-title">Paso de mensajes</div>
            </div>
            <div class="content">
                <p>El paso de mensajes es un mecanismo de comunicación entre procesos que consiste en el envío y recepción de mensajes para intercambiar información. Este método es esencial tanto en sistemas distribuidos como en sistemas monoprocesador, ya que permite la coordinación entre procesos que no comparten memoria.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <h3>Funcionamiento:</h3>
                <p>Este proceso se basa en dos operaciones primitivas fundamentales: <strong>send()</strong> (enviar) y <strong>receive()</strong> (recibir).</p>

                <h4>1. Proceso de Envío (send()):</h4>
                <ul>
                    <li>Un proceso (el <strong>emisor</strong>) quiere enviar datos a otro proceso (el <strong>receptor</strong>).</li>
                    <li>El emisor invoca la primitiva send(), especificando el <strong>destino</strong> (el ID del proceso receptor) y el <strong>mensaje</strong> a enviar.</li>
                    <li>El sistema operativo recibe el mensaje del espacio de direcciones del proceso emisor y lo almacena.</li>
                    <li>El mensaje es copiado a un <strong>búfer temporal</strong> gestionado por el sistema operativo (generalmente en el espacio de memoria del kernel).</li>
                    <li>Ya teniendo el mensaje, entonces el sistema operativo se encarga de entregar el mensaje al proceso receptor.</li>
                </ul>

                <h4>2. Proceso de Recepción (receive()):</h4>
                <ul>
                    <li>Un proceso (el <strong>receptor</strong>) invoca la primitiva receive(), especificando, opcionalmente, el <strong>origen</strong> esperado del mensaje (de qué proceso espera recibir).</li>
                    <li>El sistema operativo verifica si hay un mensaje disponible para el receptor en sus búferes internos.</li>
                    <li>Si hay un mensaje, el sistema operativo lo copia del búfer del kernel al espacio de direcciones del proceso receptor.</li>
                    <li>Si no hay un mensaje disponible, el comportamiento puede variar:
                        <ul>
                            <li><strong>Bloqueo</strong>: Este proceso se encarga de detener y bloquea el proceso hasta que llega un nuevo mensaje.</li>
                            <li><strong>No Bloqueo (Polling)</strong>: El proceso receptor recibe un valor de retorno indicando que no hay mensaje, y puede continuar con otras tareas.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Características Clave</h3>
                <ul>
                    <li><strong>Comunicación indirecta:</strong> A diferencia del modelo de memoria compartida, en este tipo de comunicación los procesos no acceden directamente a una misma región de memoria; en su lugar, el sistema operativo actúa como intermediario para el intercambio de información.</li>
                    <li><strong>Copia de Datos</strong>: Implica la copia de datos del espacio del emisor al espacio del kernel, y luego del espacio del kernel al espacio del receptor. Esto introduce una sobrecarga en comparación con la memoria compartida, pero proporciona <strong>aislamiento</strong> entre procesos.</li>
                    <li><strong>Sincronización Implícita</strong>: El paso de mensajes a menudo proporciona alguna forma de sincronización:
                        <ul>
                            <li>Si send() es <strong>bloqueante</strong>, el emisor espera hasta que el mensaje sea recibido (o al menos copiado al búfer del kernel).</li>
                            <li>Si receive() es <strong>bloqueante</strong>, el receptor espera hasta que un mensaje esté disponible.</li>
                        </ul>
                    </li>
                    <li><strong>Capacidad de Búfer</strong>: Los mensajes pueden ser almacenados temporalmente en búferes del sistema operativo. Esto puede ser:
                        <ul>
                            <li><strong>Capacidad Cero (Rendezvous)</strong>: El emisor se bloquea hasta que el receptor esté listo para recibir (y viceversa). No hay búferes intermedios.</li>
                            <li><strong>Capacidad Finita</strong>: Hay un número limitado de mensajes que se pueden almacenar en el búfer. Si el búfer está lleno, el emisor se bloquea.</li>
                            <li><strong>Capacidad Infinita</strong>: Teóricamente, el emisor nunca se bloquea al enviar. En la práctica, esto está limitado por la memoria del sistema.</li>
                        </ul>
                    </li>
                </ul>

                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <h3>Tipos de Implementación de Paso de Mensajes</h3>
                <p>La implementación puede variar en la forma de especificar la comunicación:</p>

                <h4>Comunicación Directa:</h4>
                <ul>
                    <li>send(P, mensaje): Envía un mensaje al proceso P.</li>
                    <li>receive(Q, mensaje): Recibe un mensaje del proceso Q.</li>
                    <li>Implica un acoplamiento fuerte entre emisor y receptor.</li>
                </ul>

                <h4>Comunicación Indirecta:</h4>
                <ul>
                    <li>Los mensajes se envían a y se reciben de un <strong>buzón (mailbox)</strong> o <strong>puerto</strong>.</li>
                    <li>send(A, mensaje): Envía un mensaje al buzón A.</li>
                    <li>receive(A, mensaje): Recibe un mensaje del buzón A.</li>
                    <li>Permite un acoplamiento más flexible; el emisor no necesita conocer el receptor directo, solo el buzón. Un buzón puede ser compartido por múltiples procesos.</li>
                </ul>

                <h3>Importancia</h3>
                <p>El paso de mensajes es crucial por:</p>

                <ul>
                    <li><strong>Aislamiento y Seguridad</strong>: Al copiar los mensajes, los procesos no acceden directamente a la memoria de otros, lo que mejora la seguridad y el aislamiento. Un error en un proceso no suele corromper los datos de otro a través de la comunicación.</li>
                    <li><strong>Facilidad de Uso</strong>: Es conceptualmente más simple de implementar que la memoria compartida con respecto a la sincronización, ya que el sistema operativo maneja gran parte de la coordinación.</li>
                    <li><strong>Fundamento para sistemas distribuidos:</strong> El paso de mensajes es el mecanismo principal de comunicación en sistemas distribuidos, ya que los procesos se ejecutan en máquinas diferentes y no pueden acceder a una memoria física compartida.</li>
                </ul>

                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <div class="quote-box">
                    "Aunque puede ser menos eficiente que la memoria compartida para grandes volúmenes de datos debido a la sobrecarga de copiado, su simplicidad, seguridad y aplicabilidad en entornos distribuidos lo convierten en un mecanismo de IPC indispensable."
                </div>
            </div>
        </div>

        <div class="section" id="seccion-2-3-3">
            <div class="section-header">
                <div class="section-number">2.3.3</div>
                <div class="section-title">Tuberías</div>
            </div>
            <div class="content">
                <p>Las tuberías (pipes) son un mecanismo básico de comunicación entre procesos que permite el flujo unidireccional de datos, destacándose por su simplicidad y eficiencia especialmente entre procesos relacionados.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <h3>Funcionalidad e Importancia</h3>
                <p>Las tuberías establecen un canal de comunicación simple entre procesos, destacándose por su simplicidad, comunicación unidireccional, sincronización implícita, manejo de flujo de bytes y su uso en procesos relacionados.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2018).</div>

                <p>Su importancia radica en:</p>

                <ul>
                    <li><strong>Simplicidad</strong>: Son fáciles de usar e implementar en la programación, especialmente para tareas de procesamiento de datos secuencial.</li>
                    <li><strong>Comunicación Unidireccional</strong>: Los datos fluyen en una sola dirección: un extremo es para escribir y el otro para leer. Para una comunicación bidireccional, se necesitan dos tuberías separadas.</li>
                    <li><strong>Sincronización Implícita</strong>: Las tuberías proporcionan una forma de sincronización. Si un proceso intenta leer de una tubería vacía, se bloqueará hasta que haya datos disponibles. Si un proceso intenta escribir en una tubería llena, se bloqueará hasta que el receptor lea algunos datos.</li>
                    <li><strong>Flujo de Bytes</strong>: Las tuberías manejan un flujo de bytes, sin estructura de mensajes definida, es por ello que los procesos son responsables de interpretar el formato de los datos.</li>
                    <li><strong>Comunicación entre Procesos Relacionados</strong>: Son ideales para la comunicación entre procesos que tienen una relación de parentesco (padre-hijo), ya que el proceso hijo hereda los descriptores de archivo de la tubería del proceso padre.</li>
                </ul>

                <h3>Tipos de Tuberías</h3>
                <p>Existen dos tipos principales de tuberías:</p>

                <h4>1. Tuberías Anónimas (Unnamed Pipes)</h4>
                <ul>
                    <li><strong>Funcionalidad</strong>: Son temporales y solo existen mientras los procesos que las usan están activos. No tienen un nombre en el sistema de archivos.</li>
                    <li><strong>Importancia</strong>: Se utilizan exclusivamente para la comunicación entre procesos que comparten una relación de parentesco (ej., un proceso padre crea una tubería y luego bifurca un proceso hijo que hereda los extremos de la tubería).</li>
                    <li><strong>Operatividad</strong>:
                        <ul>
                            <li>Un proceso (generalmente el padre) crea la tubería usando una llamada al sistema (ej., pipe() en sistemas Unix/Linux). Esta llamada devuelve dos descriptores de archivo: uno para lectura y otro para escritura.</li>
                            <li>El proceso padre luego crea un proceso hijo (usando fork()). El hijo hereda una copia de los descriptores de archivo de la tubería.</li>
                            <li>Para establecer la unidireccionalidad, el padre cierra el extremo de lectura y el hijo cierra el extremo de escritura (o viceversa), dependiendo de la dirección deseada del flujo de datos.</li>
                            <li>Un proceso escribe datos en el extremo de escritura, y el otro proceso lee datos del extremo de lectura.</li>
                        </ul>
                    </li>
                </ul>

                <h4>2. Tuberías Nombradas (Named Pipes o FIFOs - First-In, First-Out)</h4>
                <ul>
                    <li><strong>Funcionalidad</strong>: Son persistentes y tienen un nombre en el sistema de archivos (aparecen como un archivo especial). Esto les permite existir incluso después de que los procesos que las crearon hayan terminado.</li>
                    <li><strong>Importancia</strong>: Permiten la comunicación entre <strong>procesos no relacionados</strong> que pueden no tener un ancestro común. Cualquier proceso que conozca el nombre de la tubería puede abrirla y comunicarse a través de ella.</li>
                    <li><strong>Operatividad</strong>:
                        <ul>
                            <li>Un proceso crea la tubería nombrada usando una llamada al sistema (ej., mkfifo() en Unix/Linux). Esto crea una entrada especial en el sistema de archivos.</li>
                            <li>Cualquier proceso puede abrir esta tubería nombrada, especificando su nombre, para lectura o escritura (similar a abrir un archivo regular).</li>
                            <li>Una vez abierta, la comunicación funciona de manera similar a las tuberías anónimas: un proceso escribe y otro lee.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Operatividad General de las Tuberías</h3>
                <p>Independientemente del tipo, la operatividad básica de las tuberías implica:</p>

                <ol>
                    <li><strong>Creación</strong>: Se crea un canal de comunicación.</li>
                    <li><strong>Apertura</strong>: Los procesos abren los extremos de la tubería (uno para lectura, otro para escritura).</li>
                    <li><strong>Escritura</strong>: Un proceso escribe datos en el extremo de escritura de la tubería. Estos datos se almacenan temporalmente en un búfer del kernel.</li>
                    <li><strong>Lectura</strong>: Otro proceso lee datos del extremo de lectura de la tubería.</li>
                    <li><strong>Cierre</strong>: Una vez que la comunicación ha terminado, los procesos cierran los descriptores de archivo asociados a la tubería.</li>
                </ol>

                <div class="quote-box">
                    "El proceso básico incluye creación, apertura, escritura, lectura y cierre de la tubería, facilitando la interconexión eficiente de procesos en entornos de línea de comandos y sistemas modulares"
                    <div class="citation">(Silberschatz et al., 2018).</div>
                </div>
            </div>
        </div>

        <div class="activity-card">
            <div class="activity-title">Actividad de Aprendizaje: Modelo de Procesos</div>
            <p>Evalúa tu comprensión sobre los fundamentos, operaciones, estados e implementación de procesos en sistemas operativos.</p>
            <a href="actividad_2_1.html" class="activity-btn">
                <i class="fas fa-pencil-alt"></i> Realizar Actividad
            </a>
        </div>
        
        <div class="nav-buttons">
            <a href="2.2.html" class="nav-btn"><i class="fas fa-arrow-left"></i> Anterior: 2.2 Modelo multi-hilo</a>
            <a href="2.4.html" class="nav-btn">Continuar a 2.4: Sincronización entre procesos/hilos<i class="fas fa-arrow-right"></i></a>
        </div>
        
        <footer>
            <p>Sistemas Operativos - Unidad 2: Administración de procesos</p>
            <p>Desarrollado para fines educativos - © 2025</p>
        </footer>
    </div>

    <script>
        let sidebarOpen = false;

        const menuToggle = document.getElementById('menuToggle');
        const sidebarNav = document.getElementById('sidebarNav');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        function toggleSidebar() {
            sidebarOpen = !sidebarOpen;
            
            if (sidebarOpen) {
                sidebarNav.classList.add('active');
                sidebarOverlay.classList.add('active');
                menuToggle.classList.add('active');
                menuToggle.innerHTML = '<i class="fas fa-times"></i>';
                document.body.style.overflow = 'hidden';
            } else {
                sidebarNav.classList.remove('active');
                sidebarOverlay.classList.remove('active');
                menuToggle.classList.remove('active');
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                document.body.style.overflow = 'auto';
            }
            
            updateContainerSpacing();
        }

        menuToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        document.querySelectorAll('.nav-item[data-section]').forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth <= 768) {
                    toggleSidebar();
                }
            });
        });

        function updateContainerSpacing() {
            const container = document.querySelector('.container');
            
            if (window.innerWidth <= 768) {
                container.style.marginLeft = '20px';
                container.style.marginRight = '20px';
                container.style.padding = '10px';
            } else if (sidebarOpen && window.innerWidth > 768) {
                container.style.marginLeft = '370px';
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            } else {
                container.style.marginLeft = '90px';
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            }
        }

        function updateActiveSection() {
            const sections = document.querySelectorAll('.section');
            const navItems = document.querySelectorAll('.nav-item[data-section]');
            let currentSectionId = '';

            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 150 && rect.bottom >= 150) {
                    currentSectionId = section.id;
                }
            });

            navItems.forEach(item => {
                const sectionId = 'seccion-' + item.dataset.section;
                if (sectionId === currentSectionId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function updateReadingProgress() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        }

        const scrollToTopBtn = document.getElementById('scrollToTop');

        function toggleScrollToTopBtn() {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.classList.add('visible');
            } else {
                scrollToTopBtn.classList.remove('visible');
            }
        }

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            updateActiveSection();
            updateReadingProgress();
            toggleScrollToTopBtn();
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                
                if (target) {
                    const offsetTop = target.offsetTop - 100;
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth'
                    });
                }
            });
        });

        window.addEventListener('resize', () => {
            if (window.innerWidth > 768 && sidebarOpen) {
                toggleSidebar();
            }
            updateContainerSpacing();
        });

        document.addEventListener('DOMContentLoaded', function() {
            updateActiveSection();
            updateReadingProgress();
            updateContainerSpacing();
            if (window.innerWidth <= 768) {
                sidebarNav.classList.remove('active');
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sidebarOpen) {
                toggleSidebar();
            }
            if (e.key === 'm' || e.key === 'M') {
                if (!e.ctrlKey && !e.altKey) { 
                    toggleSidebar();
                }
            }
        });
    </script>
</body>
</html>