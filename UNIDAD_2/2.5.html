<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.5 Planificación</title>
    <link rel="icon" type="image/png" href="logoescom.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --gray: #95a5a6;
            --success: #2ecc71;
            --warning: #f39c12;
            --card-bg: rgba(255, 255, 255, 0.05);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a3a, #2c3e50);
            color: var(--light);
            min-height: 100vh;
            line-height: 1.7;
        }

        .floating-home-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 1.5rem;
        }

        .floating-home-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.4);
        }

        .sidebar-nav {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
            transition: transform 0.3s ease;
            transform: translateX(-100%);
            overflow-y: auto;
        }

        .sidebar-nav.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(52, 152, 219, 0.1);
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        }

        .sidebar-title {
            font-size: 1.2rem;
            color: var(--secondary);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .sidebar-subtitle {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .nav-sections {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 15px;
        }

        .nav-section-title {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
            margin-bottom: 10px;
        }

        .nav-item {
            display: block;
            padding: 12px 20px;
            color: var(--light);
            text-decoration: none;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-left-color: var(--secondary);
            padding-left: 25px;
        }

        .nav-item.active {
            background: rgba(52, 152, 219, 0.2);
            border-left-color: var(--secondary);
            color: var(--secondary);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--primary);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1001;
            font-size: 1.2rem;
        }

        .menu-toggle:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        .menu-toggle.active {
            background: var(--accent);
        }

        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 998;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--success));
            width: 0%;
            transition: width 0.1s ease;
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            transition: margin-left 0.3s ease, margin-right 0.3s ease;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .breadcrumb {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            color: var(--gray);
            font-size: 1.1rem;
        }
        
        .breadcrumb a {
            color: var(--secondary);
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .breadcrumb a:hover {
            color: white;
            text-decoration: underline;
        }
        
        .breadcrumb span {
            margin: 0 10px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: white;
        }
        
        .subtitle {
            font-size: 1.8rem;
            color: var(--secondary);
            margin-bottom: 20px;
            font-weight: 300;
            text-align: center;
        }
        
        .intro {
            max-width: 900px;
            margin: 0 auto 40px;
            padding: 25px;
            background: var(--card-bg);
            border-radius: 15px;
            border-left: 4px solid var(--secondary);
            text-align: justify;
        }
        
        .section {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            scroll-margin-top: 100px;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--secondary);
        }
        
        .section-number {
            font-size: 2.2rem;
            font-weight: bold;
            color: var(--secondary);
            margin-right: 15px;
            min-width: 120px;
        }
        
        .section-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: white;
        }
        
        .content {
            padding: 0 10px;
        }
        
        .content h3 {
            font-size: 1.5rem;
            color: var(--secondary);
            margin: 30px 0 15px;
            padding-left: 10px;
            border-left: 3px solid var(--accent);
        }

        .content h4 {
            font-size: 1.3rem;
            color: var(--warning);
            margin: 25px 0 12px;
            padding-left: 8px;
        }
        
        .content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .content ul, .content ol {
            padding-left: 30px;
            margin: 20px 0;
        }
        
        .content li {
            margin-bottom: 12px;
        }
        
        .highlight {
            background: rgba(231, 76, 60, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .citation {
            font-style: italic;
            color: var(--gray);
            margin: 5px 0 15px 20px;
            border-left: 2px solid var(--secondary);
            padding-left: 10px;
        }
        
        .quote-box {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--secondary);
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
            font-style: italic;
            color: var(--light);
        }

        .quote-box .citation {
            border-left: none;
            margin: 10px 0 0 0;
            padding-left: 0;
        }
        
        .table-container {
            max-width: 800px;
            margin: 30px auto;
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.2);
        }
        
        th {
            background: var(--primary);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .table-caption {
            text-align: center;
            padding: 10px;
            font-style: italic;
            color: var(--gray);
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        
        .nav-btn {
            display: inline-flex;
            align-items: center;
            background: var(--secondary);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: #2980b9;
            transform: translateY(-3px);
        }
        
        .nav-btn i {
            margin: 0 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 60px;
            padding: 30px;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
            z-index: 999;
        }

        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .scroll-to-top:hover {
            background: #c0392b;
            transform: translateY(-3px);
        }

        .activity-card {
            background: rgba(46, 204, 113, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 40px 0;
            border-left: 4px solid var(--success);
            text-align: center;
        }

        .activity-title {
            font-size: 1.8rem;
            color: var(--success);
            margin-bottom: 20px;
        }

        .activity-btn {
            display: inline-block;
            background: var(--success);
            color: white;
            padding: 15px 35px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .activity-btn:hover {
            background: #27ae60;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }
        
        @media (max-width: 768px) {
            .sidebar-nav {
                width: 100%;
            }

            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1.4rem;
            }
            
            .section-title {
                font-size: 1.5rem;
            }
            
            .section-number {
                min-width: 100px;
                font-size: 1.8rem;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
                text-align: center;
                justify-content: center;
            }

            .floating-home-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="reading-progress">
        <div class="reading-progress-bar" id="progressBar"></div>
    </div>

    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <a href="index.html" class="floating-home-btn" title="Ir al índice de unidades">
        <i class="fas fa-home"></i>
    </a>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <nav class="sidebar-nav" id="sidebarNav">
        <div class="sidebar-header">
            <div class="sidebar-title">2.5 Planificación</div>
            <div class="sidebar-subtitle">Administración de procesos</div>
        </div>
        
        <div class="nav-sections">
            <div class="nav-section">
                <div class="nav-section-title">Navegación</div>
                <a href="#inicio" class="nav-item">
                    <i class="fas fa-rocket"></i> Inicio del Tema
                </a>
                <a href="index.html" class="nav-item">
                    <i class="fas fa-arrow-left"></i> Menú de Unidad 2
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Contenido</div>
                <a href="#seccion-2-5-1" class="nav-item" data-section="2-5-1">
                    <i class="fas fa-ruler"></i> 2.5.1 Criterios
                </a>
                <a href="#seccion-2-5-2" class="nav-item" data-section="2-5-2">
                    <i class="fas fa-code-branch"></i> 2.5.2 Algoritmos
                </a>
                <a href="#seccion-2-5-3" class="nav-item" data-section="2-5-3">
                    <i class="fas fa-stream"></i> 2.5.3 Planificación de hilos
                </a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Recursos</div>
                <a href="actividad_2.5.html" class="nav-item">
                    <i class="fas fa-tasks"></i> Actividad de aprendizaje
                </a>
                <a href="index.html" class="nav-item">
                    <i class="fas fa-check-circle"></i> Completar Unidad 2
                </a>
            </div>
        </div>
    </nav>

    <button class="scroll-to-top" id="scrollToTop">
        <i class="fas fa-chevron-up"></i>
    </button>

    <div class="container">
        <header id="inicio">
            <div class="breadcrumb">
                <a href="index.html"><i class="fas fa-home"></i> Inicio</a>
                <span>/</span>
                <a href="index.html">Unidad 2</a>
                <span>/</span>
                <span>2.5 Planificación</span>
            </div>
            <h1>2.5 Planificación</h1>
            <div class="subtitle">Administración de procesos</div>
        </header>
        
        <div class="intro">
            <p>La <strong>planificación de procesos</strong> (o hilos) es una de las funciones más críticas de un sistema operativo. Se encarga de decidir qué proceso (o hilo) se ejecutará en la CPU y por cuánto tiempo, gestionando la asignación de este recurso vital entre las diversas tareas que compiten por él. Es, en esencia, el "director de orquesta" que coordina a todos los procesos para que funcionen de manera eficiente.</p>
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <br>
            <h4>Introducción a la Planificación de Procesos</h4>
            <p>En un sistema informático moderno, es común que haya muchos procesos o hilos listos para ejecutarse al mismo tiempo, incluso en máquinas con un solo procesador. Si abres un navegador web, un reproductor de música y un editor de texto, cada uno de ellos es un proceso (o un conjunto de hilos) que necesita tiempo de CPU. Sin una planificación adecuada, estos procesos chocarían entre sí, el sistema se volvería inestable o parecería lento y poco reactivo.</p>
            
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <br>
            <h4>Planificación en Sistemas Multiprocesador</h4>
            <p>La planificación se vuelve aún más compleja y crucial en sistemas multiprocesador o multinúcleo, donde múltiples CPUs pueden ejecutar procesos simultáneamente. El planificador debe no solo decidir qué proceso se ejecuta, sino también en qué núcleo se ejecuta.</p>
            
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <br>
            <h4>El Rol del Planificador (Scheduler)</h4>
            <p>La planificación se realiza mediante un componente del sistema operativo llamado planificador (<em>scheduler</em>). Este planificador selecciona, de la cola de procesos listos, cuál debe recibir el control de la CPU. Las decisiones de planificación se toman en varios momentos, como cuando un proceso termina, cuando un proceso pasa a un estado de espera (por E/S), cuando se crea un nuevo proceso o cuando ocurre una interrupción.</p>
            
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <br>
            <h4>Objetivo de la Planificación</h4>
            <p>El objetivo principal de la planificación es maximizar la eficiencia y la equidad en el uso de la CPU y otros recursos, mientras se cumplen los requisitos de rendimiento y capacidad de respuesta del sistema. Aunque los objetivos específicos pueden variar según el tipo de sistema (por lotes, interactivo, en tiempo real), los principales son los siguientes:</p>
            
            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <br>
            <ol>
                <li><strong>Utilización de CPU:</strong> Mantener la CPU tan ocupada como sea posible. Una CPU inactiva es un recurso desperdiciado. Un buen planificador busca maximizar el tiempo que la CPU está trabajando en tareas útiles.</li>
                <li><strong>Rendimiento (Throughput):</strong> Maximizar el número de procesos completados por unidad de tiempo. Esto significa ejecutar la mayor cantidad de tareas posibles en un período dado.</li>
                <li><strong>Tiempo de Retorno (Turnaround Time):</strong> Minimizar el tiempo total desde que un proceso entra al sistema hasta que se completa su ejecución. Esto incluye el tiempo que espera en la cola de listos, el tiempo de ejecución y el tiempo de E/S.</li>
                <li><strong>Tiempo de Espera (Waiting Time):</strong> Minimizar el tiempo que un proceso pasa en la cola de listos, esperando ser ejecutado. Un tiempo de espera excesivo puede hacer que el sistema parezca lento.</li>
                <li><strong>Tiempo de Respuesta (Response Time):</strong> Minimizar el tiempo desde que se envía una solicitud hasta que se produce la primera respuesta. Esto es crucial en sistemas interactivos (como el escritorio de tu computadora), donde la percepción de la velocidad es clave. Un usuario espera una respuesta casi instantánea al hacer clic en un icono.</li>
                <li><strong>Equidad (Fairness):</strong> Garantizar que cada proceso obtenga una parte justa del tiempo de CPU. Ningún proceso debe sufrir inanición (<em>starvation</em>), es decir, ser ignorado indefinidamente por el planificador.</li>
                <li><strong>Balance de Carga:</strong> En sistemas multiprocesador, el objetivo es distribuir la carga de trabajo de manera equitativa entre los núcleos de la CPU para maximizar el paralelismo.</li>
            </ol>

            <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

            <div class="quote-box">
                "Por lo tanto, la planificación es el motor que permite a los sistemas operativos manejar múltiples tareas de forma concurrente, asegurando que los usuarios obtengan una experiencia fluida y que los recursos del sistema se utilicen de manera óptima"
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>
            </div>
        </div>
        
        <div class="section" id="seccion-2-5-1">
            <div class="section-header">
                <div class="section-number">2.5.1</div>
                <div class="section-title">Criterios</div>
            </div>
            <div class="content">
                <p>La planificación de procesos en los sistemas operativos se basa en una serie de criterios que el planificador evalúa para tomar decisiones sobre qué proceso debe ejecutarse y cómo se deben asignar los recursos de la CPU. Estos criterios a menudo entran en conflicto, por lo que el planificador busca un equilibrio para optimizar el rendimiento general del sistema según su propósito.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h3>Criterios Clave en la Planificación de Procesos</h3>

                <h4>1. Utilización de la CPU (CPU Utilization)</h4>
                <ul>
                    <li><strong>Definición:</strong> Es el porcentaje de tiempo que la CPU está realmente ocupada realizando trabajo útil (ejecutando código de usuario o del sistema operativo) y no en estado de inactividad (idle).</li>
                    <li><strong>Objetivo:</strong> Maximizarla. Se busca mantener la CPU tan ocupada como sea posible para aprovechar al máximo este recurso tan costoso. Una CPU inactiva es un recurso desperdiciado.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>2. Rendimiento (Throughput)</h4>
                <ul>
                    <li><strong>Definición:</strong> El número de procesos (o tareas) que se completan por unidad de tiempo.</li>
                    <li><strong>Objetivo:</strong> Maximizarlo. Un mayor rendimiento significa que el sistema está procesando más trabajo en un período dado. Es especialmente relevante en sistemas de procesamiento por lotes.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>3. Tiempo de Retorno (Turnaround Time)</h4>
                <ul>
                    <li><strong>Definición:</strong> El tiempo total que transcurre desde que un proceso llega al sistema (entra en la cola de listos) hasta que completa su ejecución. Incluye el tiempo en la cola de listos, el tiempo de ejecución en la CPU y el tiempo de espera por operaciones de E/S.</li>
                    <li><strong>Objetivo:</strong> Minimizarlo. Un tiempo de retorno bajo significa que los trabajos se completan rápidamente.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>4. Tiempo de Espera (Waiting Time)</h4>
                <ul>
                    <li><strong>Definición:</strong> El tiempo total que un proceso pasa en la cola de procesos "listos", esperando ser asignado a la CPU. No incluye el tiempo de ejecución ni el tiempo de E/S.</li>
                    <li><strong>Objetivo:</strong> Minimizarlo. Un tiempo de espera excesivo puede hacer que el usuario perciba el sistema como lento y no responsivo.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>5. Tiempo de Respuesta (Response Time)</h4>
                <ul>
                    <li><strong>Definición:</strong> El tiempo que transcurre desde que se envía una solicitud (ej., al hacer clic en un icono o presionar una tecla) hasta que se produce la primera respuesta del sistema. No es el tiempo total de finalización, sino el tiempo hasta el inicio de la respuesta interactiva.</li>
                    <li><strong>Objetivo:</strong> Minimizarlo. Este es un criterio crucial en sistemas interactivos (escritorios, aplicaciones web), donde la inmediatez de la respuesta es vital para la experiencia del usuario.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>6. Equidad (Fairness)</h4>
                <ul>
                    <li><strong>Definición:</strong> Asegurar que cada proceso obtenga una "parte justa" del tiempo de CPU y que ningún proceso sufra inanición (starvation), es decir, que no se le niegue indefinidamente el acceso a la CPU.</li>
                    <li><strong>Objetivo:</strong> Garantizar que todos los procesos tengan una oportunidad razonable de progresar. Un sistema equitativo es más predecible y evita que procesos menos prioritarios sean ignorados.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>7. Prioridad</h4>
                <ul>
                    <li><strong>Definición:</strong> Una medida de la importancia relativa de un proceso. Los procesos con mayor prioridad generalmente tienen preferencia en el acceso a la CPU.</li>
                    <li><strong>Objetivo:</strong> Permitir que el sistema dé un mejor servicio a tareas más críticas o urgentes. Las prioridades pueden ser estáticas (fijas) o dinámicas (cambian durante la ejecución del proceso para, por ejemplo, evitar la inanición).</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>8. Balance de Carga (Load Balancing) — en sistemas multiprocesador</h4>
                <ul>
                    <li><strong>Definición:</strong> Distribuir la carga de trabajo de manera equitativa entre los múltiples núcleos de la CPU disponibles.</li>
                    <li><strong>Objetivo:</strong> Maximizar el paralelismo y la utilización general de todos los recursos de procesamiento, evitando que algunos núcleos estén sobrecargados mientras otros están inactivos.</li>
                </ul>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <div class="quote-box">
                    "La elección del algoritmo de planificación (como Round Robin, Shortest Job First [SJF], First-Come, First-Served [FCFS], etc.) impacta directamente en cómo se ponderan y se logran estos criterios. Un algoritmo puede optimizar un criterio (por ejemplo, SJF para minimizar el tiempo de retorno promedio) a expensas de otro (como la posible inanición de procesos de larga duración)"
                    <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>
                </div>
            </div>
        </div>
        
        <div class="section" id="seccion-2-5-2">
            <div class="section-header">
                <div class="section-number">2.5.2</div>
                <div class="section-title">Algoritmos</div>
            </div>
            <div class="content">
                <p>Los algoritmos de planificación de procesos son las estrategias que usa el sistema operativo para decidir qué proceso ejecutar en la CPU y por cuánto tiempo. No hay un algoritmo "perfecto", ya que cada uno optimiza ciertos criterios a expensas de otros.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h3>Tipos de Algoritmos de Planificación</h3>
                <p>Los algoritmos se clasifican principalmente en dos categorías:</p>

                <ol>
                    <li><strong>No Apropiativos (Non-Preemptive):</strong> Una vez que un proceso obtiene la CPU, la retiene hasta que termina su ejecución o voluntariamente cede el control. No puede ser interrumpido por otro proceso.</li>
                    <li><strong>Apropiativos (Preemptive):</strong> Un proceso puede ser interrumpido y la CPU puede ser asignada a otro proceso, generalmente de mayor prioridad o tras un tiempo límite.</li>
                </ol>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h3>Algoritmos Principales</h3>

                <h4>1. First-Come, First-Served (FCFS)</h4>
                <p>Se basa en el orden de llegada.</p>
                <p><strong>Ventajas:</strong> Simplicidad.</p>
                <p><strong>Desventajas:</strong> Tiempo de espera largo para procesos cortos (efecto convoy).</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Sencillo de implementar y comprender.</li>
                    <li>No hay sobrecarga por cambios de contexto innecesarios.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Puede provocar el efecto convoy, donde procesos cortos deben esperar a que terminen los largos.</li>
                    <li>No es adecuado para sistemas interactivos.</li>
                </ul>

                <h4>2. Shortest Job First (SJF)</h4>
                <p>Prioriza los procesos con ráfagas más cortas. Puede ser apropiativo o no.</p>
                <p><strong>Ventajas:</strong> Tiempo de espera promedio mínimo.</p>
                <p><strong>Desventajas:</strong> Inanición y dificultad para estimar el tiempo de ráfaga.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Minimiza el tiempo de espera promedio y el tiempo de retorno.</li>
                    <li>Óptimo para sistemas por lotes donde las ráfagas son predecibles.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Puede causar inanición si continuamente llegan procesos más cortos.</li>
                    <li>Difícil de implementar en la práctica por la necesidad de estimar la duración de los procesos.</li>
                </ul>

                <h4>3. Priority Scheduling</h4>
                <p>Planifica según la prioridad asignada a cada proceso.</p>
                <p><strong>Ventajas:</strong> Ideal para sistemas con procesos críticos.</p>
                <p><strong>Desventajas:</strong> Posibilidad de inanición; se puede corregir con envejecimiento (aging).</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Permite priorizar procesos críticos o urgentes.</li>
                    <li>Útil en sistemas donde ciertas tareas requieren atención inmediata.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Riesgo de inanición para procesos de baja prioridad.</li>
                    <li>Se necesita aplicar técnicas como el envejecimiento para corregirlo.</li>
                </ul>

                <h4>4. Round Robin (RR)</h4>
                <p>Utiliza un quantum de tiempo fijo para cada proceso.</p>
                <p><strong>Ventajas:</strong> Buen tiempo de respuesta en sistemas interactivos.</p>
                <p><strong>Desventajas:</strong> Cambio de contexto frecuente si el quantum es muy corto.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Ofrece equidad, todos los procesos reciben atención.</li>
                    <li>Bueno para sistemas interactivos por su bajo tiempo de respuesta.</li>
                    <li>Evita la inanición.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Aumenta la sobrecarga si el quantum es muy pequeño.</li>
                    <li>Si el quantum es demasiado grande, se comporta como FCFS y pierde ventajas.</li>
                </ul>

                <h4>5. Multilevel Queue Scheduling</h4>
                <p>Divide la cola de listos en varias colas por tipo de proceso.</p>
                <p><strong>Ventajas:</strong> Flexibilidad y priorización natural.</p>
                <p><strong>Desventajas:</strong> Posibilidad de inanición y dificultad para clasificar procesos.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Permite aplicar diferentes algoritmos según el tipo de proceso.</li>
                    <li>Mejora la organización y la eficiencia si las colas están bien definidas.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Puede provocar inanición en colas de menor prioridad si la planificación es estática.</li>
                    <li>Mayor complejidad en su implementación y gestión.</li>
                </ul>

                <h4>6. Multilevel Feedback Queue Scheduling</h4>
                <p>Permite que los procesos cambien entre colas según su comportamiento.</p>
                <p><strong>Ventajas:</strong> Adaptabilidad y prevención de inanición.</p>
                <p><strong>Desventajas:</strong> Alta complejidad y necesidad de ajustes precisos.</p>
                
                <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>

                <h4>Ventajas detalladas:</h4>
                <ul>
                    <li>Se adapta dinámicamente al comportamiento del proceso.</li>
                    <li>Reduce el riesgo de inanición mediante técnicas como el envejecimiento.</li>
                    <li>Combina flexibilidad, equidad y eficiencia.</li>
                </ul>

                <h4>Desventajas detalladas:</h4>
                <ul>
                    <li>Muy complejo de configurar y mantener.</li>
                    <li>Requiere ajustes finos en parámetros como número de colas, prioridades, y tiempos.</li>
                </ul>

                <div class="quote-box">
                    "La elección de un algoritmo de planificación depende en gran medida del tipo de sistema operativo y de los objetivos de rendimiento que se desean alcanzar"
                    <div class="citation">(Silberschatz, Galvin, & Gagne, 2019).</div>
                </div>
            </div>
        </div>

        <div class="section" id="seccion-2-5-3">
            <div class="section-header">
                <div class="section-number">2.5.3</div>
                <div class="section-title">Planificación de hilos</div>
            </div>
            <div class="content">
                
            </div>
        </div>
        
        <div class="activity-card">
            <div class="activity-title">Actividad de Aprendizaje: Modelo de Procesos</div>
            <p>Evalúa tu comprensión sobre los fundamentos, operaciones, estados e implementación de procesos en sistemas operativos.</p>
            <a href="actividad_2_1.html" class="activity-btn">
                <i class="fas fa-pencil-alt"></i> Realizar Actividad
            </a>
        </div>

        <div class="nav-buttons">
            <a href="2.4.html" class="nav-btn"><i class="fas fa-arrow-left"></i> Anterior: 2.4 Sincronización entre procesos/hilos</a>
            <a href="index.html" class="nav-btn">Completar Unidad 2<i class="fas fa-check-circle"></i></a>
        </div>
        
        <footer>
            <p>Sistemas Operativos - Unidad 2: Administración de procesos</p>
            <p>Desarrollado para fines educativos - © 2025</p>
        </footer>
    </div>

    <script>
        let sidebarOpen = false;

        const menuToggle = document.getElementById('menuToggle');
        const sidebarNav = document.getElementById('sidebarNav');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        function toggleSidebar() {
            sidebarOpen = !sidebarOpen;
            
            if (sidebarOpen) {
                sidebarNav.classList.add('active');
                sidebarOverlay.classList.add('active');
                menuToggle.classList.add('active');
                menuToggle.innerHTML = '<i class="fas fa-times"></i>';
                document.body.style.overflow = 'hidden';
            } else {
                sidebarNav.classList.remove('active');
                sidebarOverlay.classList.remove('active');
                menuToggle.classList.remove('active');
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                document.body.style.overflow = 'auto';
            }
            
            updateContainerSpacing();
        }

        menuToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        document.querySelectorAll('.nav-item[data-section]').forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth <= 768) {
                    toggleSidebar();
                }
            });
        });

        function updateContainerSpacing() {
            const container = document.querySelector('.container');
            
            if (window.innerWidth <= 768) {
                container.style.marginLeft = '20px';
                container.style.marginRight = '20px';
                container.style.padding = '10px';
            } else if (sidebarOpen && window.innerWidth > 768) {
                container.style.marginLeft = '370px';
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            } else {
                container.style.marginLeft = '90px';
                container.style.marginRight = '90px';
                container.style.padding = '20px';
            }
        }

        function updateActiveSection() {
            const sections = document.querySelectorAll('.section');
            const navItems = document.querySelectorAll('.nav-item[data-section]');
            let currentSectionId = '';

            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 150 && rect.bottom >= 150) {
                    currentSectionId = section.id;
                }
            });

            navItems.forEach(item => {
                const sectionId = 'seccion-' + item.dataset.section;
                if (sectionId === currentSectionId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function updateReadingProgress() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        }

        const scrollToTopBtn = document.getElementById('scrollToTop');

        function toggleScrollToTopBtn() {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.classList.add('visible');
            } else {
                scrollToTopBtn.classList.remove('visible');
            }
        }

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            updateActiveSection();
            updateReadingProgress();
            toggleScrollToTopBtn();
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                
                if (target) {
                    const offsetTop = target.offsetTop - 100;
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth'
                    });
                }
            });
        });

        window.addEventListener('resize', () => {
            if (window.innerWidth > 768 && sidebarOpen) {
                toggleSidebar();
            }
            updateContainerSpacing();
        });

        document.addEventListener('DOMContentLoaded', function() {
            updateActiveSection();
            updateReadingProgress();
            updateContainerSpacing();
            if (window.innerWidth <= 768) {
                sidebarNav.classList.remove('active');
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sidebarOpen) {
                toggleSidebar();
            }
            if (e.key === 'm' || e.key === 'M') {
                if (!e.ctrlKey && !e.altKey) { 
                    toggleSidebar();
                }
            }
        });
    </script>
</body>
</html>